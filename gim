#!/usr/bin/env python3

# Copyright (c) 2013-2016 Benjamin Althues <benjamin@babab.nl>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

try:
    from colors import green, red
except ImportError:
    green = red = lambda x: x

import os.path
import pycommand
import subprocess
import sys


class Gim(pycommand.CommandBase):
    '''Edit files by picking them from git-status or git-ls-files output'''

    usagestr = 'usage: {0} [options]'.format(os.path.basename(sys.argv[0]))
    description = __doc__
    optionList = (
        ('help', ('h', False, 'show this help information')),
        ('staged', ('s', False, 'Do not include unstaged files')),
        ('unstaged', ('u', False, 'Include unstaged files [default]')),
        ('indexed', ('i', False, 'Show indexed files only (git ls-files)')),
        ('vim', ('', '<vim executable>',
                 'Use an executable other then `vim`')),
        ('version', ('', False, 'show version information')),
    )
    version = '0.1.0'

    def run(self):
        if self.flags['help']:
            print(self.usage)
            return 0
        elif self.flags['version']:
            print('Gim version: {0} / Python version: {1} '
                  .format(self.version, sys.version.split()[0]))
            return 0

        if self.flags['indexed']:
            try:
                git_ls = self.ls_files()
            except subprocess.CalledProcessError as e:
                return 2

            if not git_ls:
                return 0

            padding = 2 if len(git_ls) > 9 else 1
            for i in git_ls:
                print('{0:{p}} {1}'
                      .format(i[0], i[1], p=padding))

            inp = input('\nSelect files to edit [{0}]: '
                        .format(green(git_ls[0][1])))
            if not inp:
                inp = '1'

            files = []
            for i in inp.split():
                try:
                    files.append(git_ls[int(i) - 1][1])
                except (IndexError, ValueError):
                    pass
        else:
            try:
                git_status = self.statuslist()
            except subprocess.CalledProcessError as e:
                return 2

            if not git_status:
                return 0

            padding = 2 if len(git_status) > 9 else 1
            for i in git_status:
                print('{0:{p}} {1}{2} {3}'
                      .format(i[0], i[1], i[2], i[3], p=padding))

            inp = input('\nSelect files to edit [{0}]: '
                        .format(red(git_status[0][3])))
            inp = inp or '1'

            files = []
            for i in inp.split():
                try:
                    files.append(git_status[int(i) - 1][3])
                except (IndexError, ValueError):
                    pass

        if files:
            try:
                subprocess.call(self.vimargs(files))
            except IOError as e:
                print(e)
                return e.errno

    def statuslist(self):
        ls = subprocess.check_output(['git', 'status', '--short']) \
            .decode('UTF-8', errors='strict').split('\n')[:-1]

        ret = []
        n = 0
        for i in ls:
            if 'M' in i[:2] or 'A' in i[:2]:
                n += 1
                ret.append((n, green(i[0]), red(i[1]), i[3:]))
            elif 'R' in i[:2]:
                n += 1
                ret.append((n, green('R'), red(i[1]), i[3:].split()[2]))
            elif '?' in i[:2] and not self.flags['staged']:
                n += 1
                ret.append((n, red(i[0]), red(i[1]), i[3:]))
        return ret

    def ls_files(self):
        ls = subprocess.check_output(['git', 'ls-files']) \
            .decode('UTF-8', errors='strict').split('\n')[:-1]
        ret = []
        n = 0
        for i in ls:
            n += 1
            ret.append((n, i))
        return ret

    def vimargs(self, files):
        VIM_EXEC = self.flags['vim'] or 'vim'

        if len(files) == 1:
            ret = [VIM_EXEC]
        elif len(files) == 2:
            cols = int(subprocess.check_output(['tput', 'cols'])
                       .decode('ascii', errors='strict'))
            if cols < 80:
                ret = [VIM_EXEC, '-p']
            elif cols < 191:
                ret = [VIM_EXEC, '-o']
            else:
                ret = [VIM_EXEC, '-O']
        else:
            ret = [VIM_EXEC, '-p']
        return ret + files

if __name__ == '__main__':
    try:
        cmd = Gim(sys.argv[1:])
        if cmd.error:
            print('error: {0}'.format(cmd.error))
            sys.exit(1)
        else:
            sys.exit(cmd.run())
    except (KeyboardInterrupt, EOFError):
        sys.exit(1)
